# ===============================================
# CustomParseMode class for sending Premium Emojis
# ===============================================

from telethon.extensions import markdown, html
from telethon import types
from telethon import TelegramClient, events

class InvalidFormatException(Exception):
    pass

class CustomParseMode:
    """
    Example using Markdown:
    - client.send_message('me', 'hello this is a [Text](spoiler), with custom emoji [❤️](emoji/10002345) !')
    
    Example using HTML:
    - client.send_message('me', 'hello this is a <a href="spoiler">Text</a>, with custom emoji <a href="emoji/10002345">❤️</a> !')
    
    Sending spoilers and custom emoji:
    https://github.com/LonamiWebs/Telethon/wiki/Sending-more-than-just-messages#sending-spoilers-and-custom-emoji
    
    :param parse_mode: 'markdown' or 'html'
    """
    def __init__(self, parse_mode: str):
        self.parse_mode = parse_mode

    def parse(self, text):
        if self.parse_mode == 'markdown':
            text, entities = markdown.parse(text)
        elif self.parse_mode == 'html':
            text, entities = html.parse(text)
        else:
            raise InvalidFormatException("Invalid parse mode. Choose either Markdown or HTML.")

        for i, e in enumerate(entities):
            if isinstance(e, types.MessageEntityTextUrl):
                if e.url == 'spoiler':
                    entities[i] = types.MessageEntitySpoiler(e.offset, e.length)
                elif e.url.startswith('emoji/'):
                    entities[i] = types.MessageEntityCustomEmoji(e.offset, e.length, int(e.url.split('/')[1]))
        return text, entities

    @staticmethod
    def unparse(text, entities):
        for i, e in enumerate(entities or []):
            if isinstance(e, types.MessageEntityCustomEmoji):
                entities[i] = types.MessageEntityTextUrl(e.offset, e.length, f'emoji/{e.document_id}')
            if isinstance(e, types.MessageEntitySpoiler):
                entities[i] = types.MessageEntityTextUrl(e.offset, e.length, 'spoiler')
        return html.unparse(text, entities)


# ===============================================
# Example: Sending messages with Premium Emojis
# ===============================================

# Replace these with your own API credentials
API_ID = 12345678
API_HASH = 'YOUR_API_HASH'
SESSION = 'my_session.session'

client = TelegramClient(SESSION, API_ID, API_HASH).start()
client.parse_mode = CustomParseMode('markdown')  # Choose 'markdown' or 'html'


async def send_premium_emoji():
    # Replace emoji ID with the corresponding Premium Emoji document ID
    msg = 'hello this is a [Text](spoiler), with custom emoji [❤️](emoji/10002345) !'
    await client.send_message('me', msg)  # Send to Saved Messages
    await client.disconnect()


# ===============================================
# Example: Getting custom emoji IDs from messages
# ===============================================

# This listens to your own messages and prints any custom emojis
@client.on(events.NewMessage(from_users='me'))
async def get_custom_emoji(event):
    message_text = event.message.message
    custom_emojis = []

    if event.entities:
        for entity in event.entities:
            if isinstance(entity, types.MessageEntityCustomEmoji):
                emoji = message_text[entity.offset:entity.offset + entity.length]
                custom_emojis.append((emoji, entity.document_id))

    for emoji, emoji_id in custom_emojis:
        print(f"Custom Emoji ID: {emoji_id} | {emoji}")


# ===============================================
# Run the bot
# ===============================================
if __name__ == "__main__":
    print("\n― Please send Premium Emoji to your 'Saved Messages'\n― Listening for messages...\n")
    with client:
        client.loop.run_until_complete(send_premium_emoji())
        client.run_until_disconnected()
